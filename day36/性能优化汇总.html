<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
    前端性能优化：
      一、减少HTTP请求次数和传输报文的大小
          - CSS SPRITE(雪碧图、图片精灵)
          - 使用字体图标(iconFont)或者使用SVG的矢量图
              + 减少请求的次数或者请求的速度(质量小)
              + 渲染时按照代码渲染的，要更快，而位图(png/jpg/gif)是需要先把图片编码在进行渲染
              + 不容易失真变形

          - 图片的懒加载
              + 第一次加载的时候不去请求真正的图片，提高第一次加载的速度
              + 当页面加载完，把出现在哟用户视野里的图片做真实加载，没有出现的先不加载，(节约流量，也能减少对服务器的压力)
          - 音视频取消预加载(perload = 'load'),这样可以增加第一次渲染页面的速度，当需要播放的时候去加载
          - 客户端和服务端的数据传输尽可能基于JSON格式完成，XML格式要比JSON格式要大
          - 把页面中的css文件和js文件行合并压缩(webpack来实现)
          - 有钱就做CDN(地狱分布式服务器)、加服务器
          - 做图片base64的处理(把图片转成base64码，这样可以减少图片的请求，提高页面渲染的速度，但是base64会导致代码变得过多，不利于开发和维护，但是以后我们使用webpack来进行base64的批量设置就好了)


      二、设置各种缓存、预处理和长连接机制
          - 把不经常更改的静态资源做缓存处理(一般都是304或者eTag协商缓存)
          - DNS的缓存和预处理，减少DNS的查找
          - 设置本地的离线存储(manifest)或者把一些不经常更改的数据做本地存储(webstorage)
          - 建立Connection:keep-alive TCP长连接
          - 建立 Cache-Control 和 Expires HTTP强缓存
          - 使用HTTP2版本协议(现在使用的是HTTP1.xxx)

      三、代码方面的优化
          - 减少对闭包的使用(因为过多使用闭包会产生不销毁的作用域，处理不好的话，会导致内存溢出)
          - 对于动画来说，能用css解决的不用js(能用transform处理的不用别的样式【硬件加速】)，能用requestAnimationFrame解决的不用定时器
              + requestAnimationFrame还有一个优势就是当页面处于休眠状态的时候，动画会自己暂停，直到恢复访问状态为止
          - 避免使用iframe(因为ifarme会嵌入其他页面，这样父页面渲染的时候，还要把子页面渲染了)
          - 减少直接对DOM的操作[回流和重绘](当代的项目都是基于mvvm、mvc数据驱动视图渲染的，对DOM的操作由框架给完成，性能要好很多)
          - 低耦合高内聚(减少页面中冗余的代码：封装:插件、组件、框架、类库、方法)
          - 尽可能使用事件委托
          - 避免出现死循环和嵌套循环
          - 在项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程的阻塞(promise)
          - 函数的防抖和节流
          - 尽可能减少安泽穷的层级(选择是从右向左进行解析) .box a{}  a{}
          - 堆栈内存的手动释放(赋值为null)
          - 对于数据我们尽可能分批加载(不要一次请求过多的数据，例如分页)
      四、安全方面的优化

      js前端代码优化的108条建议
      雅虎css代码优化的36条建议
      webpack优化
      安全优化
     */

    //  function fn(){
    //   // let a = 200;
    //   console.log(a);
    //   // fn()
    //   setTimeout(fn,1000);
    //  }
    //  fn()

    // 相互引用:引用类型之间的相互调用，形成嵌套式内存
    let obj1 = {
      name:1
    }
    let obj2 = {
      name:2,
      x:obj1
    };
    obj1.x = obj2;
  </script>
    </script>
</body>
</html>