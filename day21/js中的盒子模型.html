<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        html,body{
            height: 100%;
            width: 100%;
        }
        #outer{
            width: 300px;
            height: 300px;
            border: 10px solid;
            margin: 0 auto;
            position: relative;
        }
        #box{
            width: 200px;
            height: 200px;
            margin: 20px auto;
            background: yellowgreen;
            overflow: auto;
            line-height: 50px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="outer">
        <div id="box">
            好好学习天天向上
            
            好好学习天天向上好好学习天天向上好好学习天天向上好好学学习天天向上好好学习天天向上好好学习天天向上好好学习天天向上好好学习天天向上
            
        </div>
    </div>
    <script>
// 获取滚动条卷去的高度
  // scrollLeft scrollTop
  // scrollLeft ==>当前盒子滚动发条横向卷曲的距离
  // scrollTop ==>当前盒子滚动发条纵向卷曲的距离
  // 在13个js盒子模型里边，只有当前的scrollTop，scrollLeft是可读可写属性(既可以设置也可以读写)，其余的都是只读属性(只能读取不能设置)

  // 边界值：
  //   min = 0;
  //   max = 整个的高度(scrollHeight) - 屏幕的高度(clientHeight)

  // 获取当前屏幕的滚动条
  /*  document.documentElement.scrollTop || document.body.scrollTop;
   document.documentElement.scrollLeft || document.body.scrollLeft; */

//    function screen(attr,value){
//         // 判断用户到底想干什么，如果用户只是传递了一个参数，那就是想获取，如果传递；两个参数，那就是想设置
//        if(value === undefined){
//            return document.documentElement[attr] || document.body[attr];
//        }else{
//            document.documentElement[attr] = value;
//            document.body[attr] = value;
//        }
//    };
//    console.log(screen('clientHeight'));// 获取
//    console.log(screen('scrollTop'));// 获取
//    screen('scrollTop',0);// 设置

//    window.onscroll = function(){
//        console.log(100);
//    }
    // offsetLeft offsetTop offsetParent
    // 获取当前盒子距离父级参照物的左上偏移量

    console.log(box.offsetParent);
    // offsetParent ==>获取当前盒子的父级参照物(当前盒子的所有父元素中，谁于position定位，那他的父级参照物就是谁，默认是body)

    // offsetLeft ==>获取当前盒子距离父级参照物的左偏移量(当前盒子的外边框到父级参照物的内边框)

     // offsetLeft ==>获取当前盒子距离父级参照物的上偏移量(当前盒子的外边框到父级参照物的内边框)

     // 封装一个方法，去获取当前盒子距离body的偏移量

     function offset(ele){
        let left = ele.offsetLeft;
        let top = ele.offsetTop;
        let parent = ele.offsetParent;
        while(parent !== document.body){
             // 在原来的基础之上累加父级参照物的左border的宽度和父级参照物的左偏移量
            left += parent.clientLeft + parent.offsetLeft;
            top += parent.clientTop + parent.offsetTop;
              // 继续获父级参照物的父级参照物
            parent = parent.offsetParent;
        }
        return {left,top}
     }
     console.log(offset(center));// {left；200;top:100}
    </script>
</body>
</html>